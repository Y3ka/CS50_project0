<!DOCTYPE html>
<html>
    <head>
        <!-- Required meta tags -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <!-- Bootstrap CSS -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">    
        <link rel="stylesheet" href="sass/stylesheet.css">
        <title>GraphExpert</title>
    </head>
    <body>
        <div id="header">
            <h1>Breadth-First Search</h1>
            <img src="image/graph_logo.png" alt="website logo">
        </div>
        <div class="row">
            <div class="col-1">
                <div class="btn_group">
                    <form action="homePage.html">
                        <button type="submit">Home page</button>
                    </form>
                    <form action="Basics.html">
                        <button type="submit">Basics</button>
                    </form>
                    <form action="DFS.html">
                        <button type="submit">DFS</button>
                    </form>
                    <form action="BFS.html">
                        <button type="submit">BFS</button>
                    </form>
                    <form action="Dijkstra.html">
                        <button type="submit">Dijkstra</button>
                    </form>  
                </div>
            </div>
            <div class="col-11">
                <div class="BFS">
                    <h2>Principle:</h2>
                    <p>Breadth-First Search algorithm allows you to traverse a graph in the following way: one starts by exploring a source node, then its successors, then the unexplored successors of the successors, and so on.<br>
                        It differs from Depth-First Search by the fact that, from a source node S, it lists first the neighboors of S and then explore them one by one. Thus, this mode of operation uses a queue in which it takes the
                        first node and put at the end its unexplored neighboors.</p>
                    <p>So, the main stages of the algorithm are :</p>
                    <ol>
                        <li>Put the source node in the queue</li>
                        <li>Remove the node at the beginning of the queue to process it</li>
                        <li>Put every unexplored neighboors in the queue (since it is a queue it means at the end)</li>
                        <li>If the queue is not empty, start again at stage 2</li>
                    </ol>
                    <p>Below is an animation showing BFS applied on a graph:</p>
                    <figure>
                        <image src="image/Animated_BFS.gif" alt="animation illustrating BFS"></image>
                        <figcaption>black node = node explored, white node = node unexplored, grey node = node in the queue</figcaption>
                    </figure>

                    <h2>Complexity:</h2>
                    <p>In the worst case the complexity is O(V+E) where V is the number of nodes and E the number of edges. Let's try to understand why.<br>
                        Let's take G=(V,E), a graph where no node is explored when the algorithm is called. Every node inserted in the queue are marked as explored, the conditionnal instruction therefore ensures that all the nodes are inserted at most one time. And since the insertion is done in O(1), the complexity is O(V)<br>
                        The neighboors are given by the adjency list. They will be visited at most E time because the sum of the lengths of the adjacency lists is E (the number of edges). Thus, the final complexity is O(V+E)</p> 
                    <div class="Code">
                        <h2>Code:</h2>
                        <pre> 
                            def BFS(graph, s):
                                """Print all the elements of graph using BFS where graph is given as a adjency list and s is the source node"""
                                visited = [False]*len(graph)
                                queue = [] 
                                
                                queue.append(s)
                                visited[s] = True

                                while queue: 
                                    s = queue.pop(0)
                                    print(s, end= " ")
                                    visited[s] = True
                                    for i in graph[s]:
                                        if not visited[i]:
                                            queue.append(i)
                                            visited[i] = True
                        </pre>
                    </div>
                    
                </div>  
            </div>
        </div> 
    </body>
</html>